## 38.二叉树的深度

### 题目描述  

- 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

&nbsp;

### 解题思路  

下面的思路来自《剑指offer》。

- 思路一，递归遍历所有路径，类似于《24.二叉树中和为某一值的路径》的方法。可以创建一个全局变量用于保存当前最长路径，再创建一个全局变量用于保存当前路径的深度，然后从根节点开始向下遍历整棵树，采用前序遍历方法，每次遍历到一个结点就把当前路径深度+1，递归完毕回退的时候就把当前路径深度-1，如果是叶结点的话就比较最长路径与当前路径的长度，如果当前路径更长的话就更新最长路径的值。但是这种方法代码实现比较复杂。
- 思路二，动态规划，与《8.跳台阶》和《9.变态跳台阶》之类的动态规划题目比较类似。如果一棵树只有一个结点，它的深度为1。如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。


&nbsp;

### 代码 

- 思路二，动态规划，C++

```c++
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    int TreeDepth(TreeNode* pRoot)
    {
        if(pRoot == NULL) return 0;
        
        int nLeft = TreeDepth(pRoot->left);
        int nRight = TreeDepth(pRoot->right);
        
        return (nLeft > nRight) ? (nLeft+1) : (nRight+1);
    }
};
```



