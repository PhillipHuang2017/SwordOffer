## 67.剪绳子

### 题目描述  

- 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为`k[0],k[1],...,k[m]`。请问`k[0]*k[1]*...*k[m]`可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

#### 输入描述:

```
输入一个数n，意义见题面。（2 <= n <= 60）
```

#### 输出描述:

```
输出答案。
```

#### 示例1

- 输入

```
8
```

- 输出

```
18
```

&nbsp;

### 解题思路  

- 思路一，动态规划。

题目考察的是贪心算法，其实就是把每种情况都试一遍，所以贪心。假如绳子长度为`n`，最后一段的长度是`x`，那么不管前面怎么切，前面切出来的结果乘积最大的话，再乘上`x`切割的最大结果也是最大的，因此要得到`f(n)`的解，就是求`max(f(1)*f(n-1), f(2)*f(n-2), ..., f(n-1)*f(1))`，看起来是不是对称了，因此简化一下，即`max(f(1)*f(n-1), f(2)*f(n-2), ..., f(n//2)*f(n-n//2))`。

但是直接这样向下递归的话递归层数就太多了，而且有太多重复的计算。因此可以从`f(1)`往上求，把求过的结果保存下来，这样当求`f(n)`的时候，就已经知道了`f(1), ..., f(n-1)`的结果，就不需要再向下递归了，可以用长度为`n-1`的数组来保存这些中间结果。

- 思路二，2和3的个数，来自牛客网题解。

我们仔细想一下，当剩下的绳子长度`>=4`的时候，一定是切比不切要好（4的时候切和不切一样），因此可以把结果看成好多个2和3的乘积，那当然是3越多越好，不够的时候就用1个2或者2个2凑上，因此可以看输入数字可以由多少个3相加得到，即`n/3`，但是有时候不能整除，因此还要算剩下的数里面有几个2，剩下的数肯定是1或2（即除以3的余数），剩下1的话就把3的数量减1, 2的数量就为2，即剩下一个4出来；剩下的是2的话那就2的数量为1就好。然后把这些2和3全都乘起来，即3的多少次方乘以2的多少次方。

- 思路三，从中间分为两份，来自牛客网题解。

该思路认为，如果绳子分为很多段的话，那么其实可以把这些段划分为两组，前面的为一组，后面的为一组，然后再求解这两大段的最优解。那么问题就变成，首先将绳子分为两段，那么这就是长宽和一定的情况下，如何围成一个最大矩形的问题，一定是正方形最大，因此将绳子从中间分为两段，即`f(n//2)`和`f(n-n//2)`剩下的就是求解这两个的最大值问题。也是从小往大求，`f(1), f(2), f(3)`是已知的，分别为`1,2,3`（当然如果绳子总长为3米的话返回值还是2），往后求`f(4) = f(4//2)*f(4-4//2)=f(2)*f(2)`，然后再往后依次求到`f(n)`即可，看代码更容易理解，其实仔细想想的话，和思路二有异曲同工之妙。


&nbsp;

### 代码 

- 思路一，动态规划。

```c
class Solution {
private:
    void f(int* history, int number){
        int max = number;  // 因为如果number不是原来整根绳子的长度的话，不减至少不是最坏的
        int mid = number/2;
        for(int i=1; i<=mid; i++){
            int result = history[i-1]*history[number-i-1];  // 下标为n-1的位置存的是n的结果
            if(result > max) max = result;
        }
        history[number-1] = max;
    }
public:
    int cutRope(int number) {
        // 1和2的结果都是1，因为至少切两段
        if(number < 3) return 1;
        if(number == 3) return 2;
        // history中下标为n-1的位置代表f(n)的结果
        int history[number];
        memset(history, 0, sizeof(history)); // 不初始化也行，但最好养成习惯初始化一下
        // 只剩下2米或者3米的时候也可以不切，因此可以设置f(2)为2，f(3)为3
        // 剩下4米的话结果和整根绳子4米的结果是一样的，因此设不设置都行
        // 从5米开始就是切开比不切要好了
        // 但要注意如果整根绳子长度为2的话结果是1，因为至少切1次
        history[0] = 1;
        history[1] = 2;
        history[2] = 3;
        for(int i=4; i<=number; i++) f(history, i); // 依次从小到达计算前面的结果
        return history[number-1];
    }
};
```

- 思路二，2和3的个数，来自牛客网题解。

```c
class Solution {
public:
    int cutRope(int number) {
        if(number < 2)
            return 0;
        if(number == 2)
            return 1;
        if(number == 3)
            return 2;
        int timesOf3 = number/3;
        if(number - timesOf3*3 == 1)
            timesOf3 -= 1;
        int timesOf2 = (number - timesOf3*3)/2;
         
        return pow(3,timesOf3)*pow(2,timesOf2);
    }
};
```

- 思路三，从中间分为两份，来自牛客网题解。

```c
class Solution {
public:
    int cutRope(int number) {
        if (number <= 1)
            return 0;
        if (number == 2)
            return 1;
        if (number == 3)
            return 2;
        vector<int> backup = { 0,1,2,3 }; //这里被减去的绳子段与前面返回结果的值有所不同
        for (int i = 4; i != number + 1; i++) {
            int j = i / 2;                  //一般趋于最中间的两个数乘积是最大的，因为正方形面积最大。
            backup.push_back(backup[j] * backup[i - j]);
        }
        return backup[number];
    }
};
```

