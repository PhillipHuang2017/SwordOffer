## 46.孩子们的游戏(圆圈中最后剩下的数)

### 题目描述  

- 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

  如果没有小朋友，请返回-1。

- 简洁版题目：`0,1,...,n-1`这些数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第`m`个数字。求出这个圆圈里剩下的最后一个数字。即约瑟夫环问题。   

&nbsp;

### 解题思路  

下面的思路来自《剑指offer》。

- 思路一，链表模拟法，面试的时候先用这种方法，能更快解出来。

  通过链表的方式，按题目要求每次将一个结点去掉即可，注意遍历到链表结尾的时候把迭代器恢复到开头。可以借助于STL中的`list`双向链表，如果不让用标准库的话就自己定义一个双向链表。每删除一个数字需要运算`m`次，总共要删除`n-1`个数字，时间复杂度$O(mn)$，空间复杂度$O(n)$。

- 思路二，找规律计算法，面试的时候能不用就不用，因为比较复杂，有限时间内可能推不出来。

  假设第一个出去的人的编号为`k`，易得$k=(m-1)\%n$，那么他出去以后就会以他后面的那个人为开头重新进行游戏，相当于第二轮的时候数组变成了`k+1, k+2, ..., n-1, 0, 1, ..., k-1`，相当于对这个新的数组求解上面的问题，这个数组的解和原始数组的解应该是一样的，因此如果把这个数组的编号进行映射：   

  ```
  k+1  -->  0
  k+2  -->  1
  ...
  n-1  -->  n-k-2  (因为原始数组k后面总共有n-1-k个数字，注意编号从0开始)
  0    -->  n-k-1
  1    -->  n-k
  ...
  k-1  -->  n-2   （因为总共还剩下n-1个数字）
  ```

  映射的公式为：公式1，$y = (x+(n-k-1))\%n$，（为什么和`n`取模呢，我是把`x=k+1`带进去试出来的）表示原来的编号为`x`的话映射后就是`y`，同样通过找规律写出反向映射的公式：公式2，$x = (y+k+1)\%n$，（为什么和`n`取模呢？我是把`y=n-k-1`带进去试出来的），将$k=(m-1)\%n$。实带入则公式2变成：$x = (y+(m-1)\%n+1)\%n=(y+m)\%n$。际上只需要把公式2推出来就行，公式1用不上。

  假设上面的题目的解为`f(n, m)`，即`n`个数字，每次删除第`m`个，`f(n,m)`就表示最后剩下的那个数字的编号，那么如果我们能求出`f(n-1,m)`，即公式2中的`y`，就可以利用公式2求出`f(n,m)`，即公式2中的`x`，因此得到下面的公式：   
  $$
  f(n,m)=\begin{cases}
  0&n=1 \\
  (f(n-1,m)+m)\%n&n>1
  \end{cases}
  $$
  有了这个公式以后就可以很快的通过递推得到结果，而且不需要额外的空间消耗。   


&nbsp;

### 代码 

- 思路一，链表模拟法，面试的时候先用这种方法，虽然效率不高，但能更快解出来。

```c
class Solution {
public:
    int LastRemaining_Solution(int n, int m)
    {
        if(n<1 || m<1) return -1;
        
        list<int> numbers;
        for(int i=0; i<n; i++) numbers.push_back(i);
        
        list<int>::iterator current = numbers.begin();
        while(numbers.size()>1){
            for(int i=0; i<m-1; i++){
                current++;
                if(current == numbers.end()) current = numbers.begin();
            }
            current = numbers.erase(current);
            if(current == numbers.end()) current = numbers.begin();
        }
        return *current;
    }
};
```

- 思路二，找规律计算法，面试的时候能不用就不用，因为比较复杂，有限时间内可能推不出来。

```c
class Solution {
public:
    int LastRemaining_Solution(int n, int m)
    {
        if(n<1 || m<1) return -1;
        
        int last = 0;
        for(int i=2; i<=n; i++){
            last = (last+m)%i;
        }
        return last;
    }
};
```



